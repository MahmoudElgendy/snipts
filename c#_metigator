
&& || short circits can save me alot of time

a ^ b => only true if both are different 

int x=1;
int y=2;
int z=x+y;
print(z) => good for readability

print (x+y)=> good for performance
Ternary opetator:- 
string x= (x==y)? "accept" :"reject" 

Array => reference type values is fixed and next to eachother in the mempry
array types => normal, multidimention , jagged(array of not equal array more petter i in performance)

var frinds = new string{"a","b","c","d","e"};
var slice = frinds[..2] ====> a,b
var slice = frinds[2..3] ====>c
var slice = frinds[2..^2] ====>c (starting from 2 skipp last 2 elements (not indexes)

var sliceRange = ..2;
var scile = frinds[sliceRange]

outofrange exception you want index larger than array length.
-----------------------------------------------------------------------------
empty string not null
Expressions:- (anu thing ends with single value)

primary expressions => has value 
null operators

null coalescing ??
string s1= null;
 s1=s1??"Issam";
 
 conditional null(used to solve null reference exception)
  string s1= null;
  var s2 =S1?.ToUpper(); ===> var s2 = (s1 is null):null : s1.toupper();
  -----------------------------------------------------------------------------
  delegates:-
  passing condition to  a function (make condition dynamic)
  or you can say pass peice of function
 multicaste delegate can refer to more than one function
 
 -----------------------------------------------------------------
 
 generic function
 generic class
 generic constratints => class any<T> where T : class , new ()
 colletcons vs generic lists
 collections not type save ex(ArrayList)
 --------------------------------------------------------------------
  generic delegate types
  Action => return void , take up to 16 paramenter
  Func => retrun one value , take up to 16 parameter
  Predicate => return one boolean and take one parameter
------------------------------------------------------------
threading 
t1.join()=> means first finish t1 thin consume with other threads
race condition=> I don't know which thread will be executed first even if i use join() that happens when 2 or more thread execute the same code 
the solution is to use lock (grant only on object excute the pice of code at same time)
Deadlock=> two or more thread waiting for each other to execute
we can handle deadlock by using monitor
thread pool=>pre created threads to help readuce costs
 
